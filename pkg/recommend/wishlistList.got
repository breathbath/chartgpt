package recommend

import (
	"breathbathChatGPT/pkg/auth"
	"breathbathChatGPT/pkg/msg"
	"breathbathChatGPT/pkg/utils"
	"context"
	"fmt"
	"github.com/sirupsen/logrus"
	"gorm.io/gorm"
	"strings"
)

const ListFavoritesCommand = "/list_favorites"
const NoFavoritesContextMessage = `Ты электронный сомелье WineChefBot. Сообщи у данного юзера список избранный вин пустой и предложи добавить несколько вин. Используй эмоциональный, краткий и неформальный текст.`

type ListFavoritesHandler struct {
	db      *gorm.DB
	respGen ResponseGenerator
}

func NewListFavoritesHandler(db *gorm.DB, respGen ResponseGenerator) *ListFavoritesHandler {
	return &ListFavoritesHandler{
		db:      db,
		respGen: respGen,
	}
}

func (afh *ListFavoritesHandler) CanHandle(_ context.Context, req *msg.Request) (bool, error) {
	if !utils.MatchesCommand(req.Message, ListFavoritesCommand) {
		return false, nil
	}

	return true, nil
}

func (afh *ListFavoritesHandler) handleErrorCase(ctx context.Context) (*msg.Response, error) {
	log := logrus.WithContext(ctx)

	responseMessage := utils.SelectRandomMessage(AddToFavoritesErrorMessages)

	log.Debugf("Selected a random message for add to favorites failure : %q", responseMessage)

	return &msg.Response{
		Message: responseMessage,
		Type:    msg.Error,
		Options: &msg.Options{},
	}, nil
}

func (afh *ListFavoritesHandler) handleListEmpty(ctx context.Context) (*msg.Response, error) {
	log := logrus.WithContext(ctx)

	responseMessage := utils.SelectRandomMessage(AddToFavoritesErrorMessages)

	log.Debugf("Selected a random message for add to favorites failure : %q", responseMessage)

	return &msg.Response{
		Message: responseMessage,
		Type:    msg.Error,
		Options: &msg.Options{},
	}, nil
}

func (afh *ListFavoritesHandler) handleSuccessCase(ctx context.Context, req *msg.Request, favWines []Wine) (*msg.Response, error) {
	log := logrus.WithContext(ctx)

	responseMessage := utils.SelectRandomMessage(AddToFavoritesErrorMessages)

	log.Debugf("Selected a random message for add to favorites failure : %q", responseMessage)

	userFields := []string{}
	responseFields := []string{}
	if req.Sender.FirstName != "" {
		userFields = append(userFields, "Имя: "+req.Sender.FirstName)
	}
	if req.Sender.LastName != "" {
		userFields = append(userFields, "Фамилия: "+req.Sender.LastName)
	}

	if len(userFields) > 0 {
		responseFields = append(responseFields, strings.Join(userFields, ", "))
	}

	if w.WineTextualSummaryStr() != "" {
		responseFields = append(responseFields, fmt.Sprintf("Рекомендованное вино: %s", w.WineTextualSummaryStr()))
	}

	responseMessage, err := afh.respGen.GenerateResponse(
		ctx,
		AddToFavoritesContextMessage,
		strings.Join(responseFields, "."),
		"add_favorites_response",
		req,
	)
	if err != nil {
		log.Errorf("failed to generate add to favorites response message: %v", err)
		m := utils.SelectRandomMessage(AddToFavoritesFallbackMessages)
		return &msg.Response{
			Message: m,
			Type:    msg.Success,
			Options: &msg.Options{},
		}, nil
	}

	return &msg.Response{
		Message: responseMessage,
		Type:    msg.Success,
		Options: &msg.Options{},
	}, nil
}

func (afh *ListFavoritesHandler) Handle(ctx context.Context, req *msg.Request) (*msg.Response, error) {
	log := logrus.WithContext(ctx)
	log.Debugf("Will handle list favorites for message %q", req.Message)

	usr := auth.GetUserFromReq(req)
	if usr == nil {
		log.Error("Failed to find user data in the current request")
		return afh.handleErrorCase(ctx)
	}

	var wineFavorites []WineFavorite
	res := afh.db.Preload("Wine").Where("user_login = ?", usr.Login).Find(&wineFavorites)
	if err := res.Error; err != nil {
		log.Errorf("failed to find favorites for user %q: %v", usr.Login, err)
		return afh.handleErrorCase(ctx)
	}

	log.Debugf("Found %d favorites for user %q", usr.Login)
	wineSummary := []string{}
	for _, wineFavorite := range wineFavorites {
		wineSummary = append(wineSummary, wineFavorite.Wine.SummaryStr())
	}

	return afh.handleSuccessCase(ctx, req, favoriteWines)
}
